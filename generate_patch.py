#!/bin/python
from pathlib import Path
import zlib
import sys
import subprocess
import re
import struct
from collections import defaultdict


ARM9_ROM_ADDRESS = 0x02004000
ARM9_CONTROLS_INIT_HOOK_ADDR = 0x020049EC
ARM9_CONTROLS_BASE_PATCH_ADDR = 0x02004b00

# rom_path = "Super Mario 64 DS (USA).nds"
rom_path = sys.argv[1] if len(sys.argv) > 1 else ""

tmp_folder_name = "tmp_ndstools"
arm7_update_rtcom_function_name = "Update_RTCom"

ndstool_exe_path = "ndstool"
asm_exe_path = "arm-none-eabi-as"
objcopy_exe_path = "arm-none-eabi-objcopy"
objdump_exe_path = "arm-none-eabi-objdump"
ld_exe_path = "arm-none-eabi-ld"
make_exe_path = "make"

ndstool_params = [
    "-9", f"{tmp_folder_name}/arm9.bin",
    "-7", f"{tmp_folder_name}/arm7.bin",
    "-y9", f"{tmp_folder_name}/y9.bin",
    "-y7", f"{tmp_folder_name}/y7.bin",
    "-d", f"{tmp_folder_name}/data",
    "-y", f"{tmp_folder_name}/overlay",
    "-h", f"{tmp_folder_name}/header.bin",
    "-t", f"{tmp_folder_name}/banner.bin",
]

arm9_rom_function_offsets = {
    # Address to insert branch for controls hook; sqrt func; getangle func; controls struct address; hide virtual joystick addr
    "ASMP-D3D9F14A": [0x202C408, 0x0203d744, 0x0203b4dc, 0x0209f498, 0x020FA7E4],
    "ASMJ-D2BBD1E6": [0x202B5E4, 0x0203c4d0, 0x0203a26c, 0x0209803c, 0x020F178C],
    "ASMJ-D2F380B2": [0x202B5AC, 0x0203bd0c, 0x02039aa8, 0x02096f7c, 0x020F05AC],
    "ASMK-3C73EADE": [0x202B3E8, 0x0203bdd4, 0x0203a158, 0x0209e548, 0x020F97A4],
    "ASME-AEA63749": [0x202B324, 0x0203b898, 0x02039684, 0x02097594, 0x020F0DAC],
    "ASME-F486F859": [0x202B5E8, 0x0203c4d4, 0x0203a270, 0x02098ad8, 0x020F286C],
    "ASMC-4F664FC5": [0x202D738, 0x0203ec48, 0x0203c9e0, 0x020aa6dc, 0x021058C4],
}

arm9_mode_specific_btn_map_table_address = {
    "ASMP-D3D9F14A": 0x02075650,
    "ASMJ-D2BBD1E6": 0x02074160,
    "ASMJ-D2F380B2": 0x020738c0,
    "ASMK-3C73EADE": 0x0206ff0c,
    "ASME-AEA63749": 0x0207331c,
    "ASME-F486F859": 0x0207403c,
    "ASMC-4F664FC5": 0x020738a0,
}

arm7_rom_offsets = {
    # rtc init call instr (at rtc init call addr); rtc init call addr; rtc code block start addr; vblank handler end addr
    "ASMP-D3D9F14A": [0xEB002857, 0x037f837c, 0x03801d44, 0x037f85f4],
    "ASMJ-D2BBD1E6": [0xEB002857, 0x037f837c, 0x03801d44, 0x037f85f4],
    "ASMJ-D2F380B2": [0xEB002857, 0x037f837c, 0x03801d44, 0x037f85f4],
    "ASMK-3C73EADE": [0xEB002857, 0x037f837c, 0x03801d44, 0x037f85f4],
    "ASME-AEA63749": [0xEB002867, 0x037f837c, 0x03801d84, 0x037f85f4],
    "ASME-F486F859": [0xEB002857, 0x037f837c, 0x03801d44, 0x037f85f4],
    "ASMC-4F664FC5": [0xEB002857, 0x037f837c, 0x03801d44, 0x037f85f4],
}

rom_descriptions = {
    "ASMP-D3D9F14A": "Europe v1.0",
    "ASMJ-D2BBD1E6": "Japan v1.1",
    "ASMJ-D2F380B2": "Japan v1.0",
    "ASMK-3C73EADE": "Korea v1.0",
    "ASME-AEA63749": "USA v1.0",
    "ASME-F486F859": "USA v1.1",
    "ASMC-4F664FC5": "China v1.0 (iQue)"
}


def find_function_offset_in_asm_listing(asm_code, func_name):
    asm_func_regexp = r"([a-f0-9]{8}) .+" + func_name + "[^-+].+"
    regexp_func = re.search(asm_func_regexp, asm_code, re.IGNORECASE)
    if regexp_func:
        addr = int(regexp_func.group(1), 16)
    else:
        raise Exception(f"Can't find the function '{func_name}' in the object file")
    return addr


def assemble_arm9_controls_hook_patch(asm_symbols_params):
    patch_asm_filename = "arm9_controls_hook.s"
    assembled_patch_filename = f"{tmp_folder_name}/ARM9_CONTROLS_HOOK_PATCH.bin"

    subprocess.check_output([asm_exe_path, patch_asm_filename, '-o',
                             f'{tmp_folder_name}/arm9_controls_hook.o', *asm_symbols_params])
    subprocess.check_output([objcopy_exe_path, '-Obinary',
                            f'{tmp_folder_name}/arm9_controls_hook.o', assembled_patch_filename])

    asm_code = subprocess.check_output([objdump_exe_path, '-d', f'{tmp_folder_name}/arm9_controls_hook.o'], text=True)

    return bytearray(open(assembled_patch_filename, "rb").read()), asm_code


def assemble_arm7_rtcom_patch(rtc_code_block_start_addr, include_nub):
    def generate_header_file_with_byte_array(patch_path, header_output):
        code_binary = open(patch_path, 'rb').read()
        with open(header_output, "w") as twl_bg_header_file:
            twl_bg_header = "// The file was automatically generated by the script 'generate_patch.py' from 'arm11_twlbg_patch.s'\n"
            twl_bg_header += "#pragma once\n"
            twl_bg_header += "unsigned char twlbg_patch_code[] = {"
            for i, b in enumerate(code_binary):
                if i % 10 == 0:
                    twl_bg_header += "\n"
                twl_bg_header += f"0x{b:02X}, "
            twl_bg_header = twl_bg_header.strip(", ")
            twl_bg_header += "};\n "
            twl_bg_header_file.write(twl_bg_header)

    arm7_patch_dir = 'arm7_rtcom_patch'

    # Assemble the TwlBg runtime patch
    twlbg_patch_dir = f"{arm7_patch_dir}/arm11_ucode/arm11_twlbg_patch"

    subprocess.check_output([asm_exe_path, "arm11_twlbg_patch.s", "-o", "arm11_twlbg_patch.out"], cwd=twlbg_patch_dir)
    subprocess.check_output([objcopy_exe_path, "-Obinary", "arm11_twlbg_patch.out",
                            "TWLBG_PATCH.NO_NUB.bin"], cwd=twlbg_patch_dir)
    subprocess.check_output([asm_exe_path, "arm11_twlbg_patch.s", "-o", "arm11_twlbg_patch.out",
                            "--defsym", "INCLUDE_NEW_3DS_STUFF=1"], cwd=twlbg_patch_dir)
    subprocess.check_output([objcopy_exe_path, "-Obinary", "arm11_twlbg_patch.out",
                            "TWLBG_PATCH.WITH_NUB.bin"], cwd=twlbg_patch_dir)

    # generate an includable header file with the TwlBg patch's binary
    generate_header_file_with_byte_array(f"{twlbg_patch_dir}/TWLBG_PATCH.NO_NUB.bin",
                                         f"{twlbg_patch_dir}/twl_bg_patch_bytes.no_nub.h")
    generate_header_file_with_byte_array(f"{twlbg_patch_dir}/TWLBG_PATCH.WITH_NUB.bin",
                                         f"{twlbg_patch_dir}/twl_bg_patch_bytes.with_nub.h")

    ####################################################################################

    subprocess.check_output([make_exe_path, 'clean', '--directory', arm7_patch_dir])

    include_nub_param = 'EXTERNAL_DEFINES=' + ('-DINCLUDE_NEW_3DS_STUFF' if include_nub else '')
    try:
        subprocess.check_output(
            [make_exe_path, include_nub_param, '--directory', arm7_patch_dir],
            stderr=subprocess.STDOUT)
    except subprocess.CalledProcessError as e:
        print(e.output.decode('utf-8'))
        exit(-1)

    try:
        subprocess.check_output(
            [ld_exe_path, 'rtcom.o', f'{arm7_patch_dir}.uc11.o', '--output', 'arm7_patch.o', '--section-start',
             f'.text={hex(rtc_code_block_start_addr)}'],
            stderr=subprocess.DEVNULL, cwd=f'{arm7_patch_dir}/arm7/build/')
    except subprocess.CalledProcessError as e:
        print(e.output.decode('utf-8'))
        exit(-1)

    subprocess.check_output(
        [objcopy_exe_path, '-O', 'binary', '--only-section=.rodata', '--only-section=.text', 'arm7_patch.o',
         'arm7_patch.bin'],
        cwd=f'{arm7_patch_dir}/arm7/build/')
    arm7_patch_bytes = open(f'{arm7_patch_dir}/arm7/build/arm7_patch.bin', 'rb').read()

    rtcom_asm_code = subprocess.check_output([objdump_exe_path, '-d', 'rtcom.o'],
                                             cwd=f'{arm7_patch_dir}/arm7/build/', text=True)
    update_rtcom_func_offset = find_function_offset_in_asm_listing(rtcom_asm_code, arm7_update_rtcom_function_name)

    return update_rtcom_func_offset, arm7_patch_bytes


def get_asm_symbols_params(instr_to_replace, sqrt_func, getangle_func, controls_struct, hide_virt_joystick):
    return [
        "--defsym", "INPUT_UPDATE_INJECT_ADDRESS=" + hex(instr_to_replace),
        "--defsym", "SQRT_FUNC_ADDRESS=" + hex(sqrt_func),
        "--defsym", "GET_ANGLE_FUNC_ADDRESS=" + hex(getangle_func),
        "--defsym", "CONTROLS_STRUCT_ADDRESS=" + hex(controls_struct),
        "--defsym", "HIDE_VIRTUAL_JOYSTICK_ADDR=" + hex(hide_virt_joystick),
        "--defsym", "INIT_HOOK_ADDR=" + hex(ARM9_CONTROLS_INIT_HOOK_ADDR),
        "--defsym", "BASE_PATCH_ADDR=" + hex(ARM9_CONTROLS_BASE_PATCH_ADDR),
    ]


def patch_rom(rom_path, include_nub):
    # this function could (and maybe still can) patch a ROM directly, without having to use an Action Replay cheat code
    def get_rom_signature():
        ROM_GAME_CODE_OFFSET = 0x0C
        with open(rom_path, 'rb') as asm9_file_read:
            header = asm9_file_read.read(0x200)

        gamecode = struct.unpack_from('4s', header, ROM_GAME_CODE_OFFSET)[0].decode()
        header_crc32_jamcrc = ~zlib.crc32(header) & 0xFFFFFFFF
        return f"{gamecode}-{header_crc32_jamcrc:08X}"

    def patch_arm9(rom_id):
        with open(f"{tmp_folder_name}/arm9.bin", "rb") as asm9_file_read:
            arm9_code = bytearray(asm9_file_read.read())

        # insert the initial activating hook
        branch_instr = 0xEA000000 | ((ARM9_CONTROLS_BASE_PATCH_ADDR - ARM9_CONTROLS_INIT_HOOK_ADDR - 8) >> 2)
        addr = ARM9_CONTROLS_INIT_HOOK_ADDR - ARM9_ROM_ADDRESS
        struct.pack_into("<I", arm9_code, addr, branch_instr)

        current_rom_offsets = arm9_rom_function_offsets[rom_id]
        patch_code, _ = assemble_arm9_controls_hook_patch(get_asm_symbols_params(*current_rom_offsets))

        relative_base_addr = ARM9_CONTROLS_BASE_PATCH_ADDR - ARM9_ROM_ADDRESS
        arm9_code[relative_base_addr:relative_base_addr+len(patch_code)] = patch_code

        print(f"A9: Patch size: 0x{len(patch_code):08X}")

        with open(f"{tmp_folder_name}/arm9.bin", "wb") as asm9_file_write:
            asm9_file_write.write(arm9_code)

    def patch_arm7(rom_id, include_nub):
        _, rtc_init_call_addr, rtc_code_block_addr, vblank_handler_exit_addr = arm7_rom_offsets[rom_id]

        update_rtcom_func_offset, arm7_patch_bytes = assemble_arm7_rtcom_patch(rtc_code_block_addr, include_nub)
        branch_to_rtcom_update_instruction = 0xEA000000 + (
            ((rtc_code_block_addr + update_rtcom_func_offset - vblank_handler_exit_addr - 8) >> 2) & 0xFFFFFF)

        rel_offset = 0x37F7E98
        arm7_rtc_init_call_addr = rtc_init_call_addr - rel_offset
        arm7_rtc_code_block_addr = rtc_code_block_addr - rel_offset
        arm7_vblank_irq_handler_end_addr = vblank_handler_exit_addr - rel_offset

        print(f"A7: 'Branch to Update_RTCom'-instruction: 0x{branch_to_rtcom_update_instruction:08X}")
        print(
            f"A7: Patch Update RTCom func offset: 0x{update_rtcom_func_offset:08X} (0x{update_rtcom_func_offset+rel_offset:08X})")
        print(f"A7: Patch size: 0x{len(arm7_patch_bytes):08X}")
        print(f"A7: Init RTC Call addr: 0x{arm7_rtc_init_call_addr:08X} (0x{rtc_init_call_addr:08X})")
        print(f"A7: RTC Code Block start addr: 0x{arm7_rtc_code_block_addr:08X} (0x{rtc_code_block_addr:08X})")
        print(
            f"A7: VBlank Handler end address: 0x{arm7_vblank_irq_handler_end_addr:08X} (0x{vblank_handler_exit_addr:08X})")

        with open(f"{tmp_folder_name}/arm7.bin", "rb") as asm7_file_read:
            arm7_code = bytearray(asm7_file_read.read())

        struct.pack_into('<I', arm7_code, arm7_rtc_init_call_addr, 0)
        struct.pack_into('<I', arm7_code, arm7_vblank_irq_handler_end_addr, branch_to_rtcom_update_instruction)
        arm7_code[arm7_rtc_code_block_addr:arm7_rtc_code_block_addr+len(arm7_patch_bytes)] = arm7_patch_bytes

        with open(f"{tmp_folder_name}/arm7.bin", "wb") as asm7_file_write:
            asm7_file_write.write(arm7_code)

    rom_id = get_rom_signature()
    print(f"A9: Current Gamecode + 'Header CRC32/JAMCRC' = '{rom_id}'")

    subprocess.check_output([ndstool_exe_path, "-x", rom_path, *ndstool_params])
    patch_arm9(rom_id)
    patch_arm7(rom_id, include_nub)
    subprocess.check_output([ndstool_exe_path, "-c", "new_" + Path(rom_path).name, *ndstool_params])


def generate_action_replay_code(rom_id, include_nub):
    def ar_code__bulk_write(bin: bytearray, address: int):
        if len(bin) % 8 != 0:  # make the size a multiple of 8
            bin += b'\x00' * (8 - len(bin) % 8)
        ar_code = f"E{address:07X} {len(bin):08X}\n"
        for words in struct.iter_unpack("<II", bin):
            ar_code += f"{words[0]:08X} {words[1]:08X}\n"
        return ar_code

    def instr__arm_b(from_addr, target, link=False, exchange=False):
        offset = target - (from_addr + 8)
        if exchange:  # blx
            instr_type = 0xFA000000 if (offset & 0x2) == 0 else 0xFB000000
            return instr_type | ((offset >> 2) & 0xFFFFFF)
        else:
            instr_type = 0xEB000000 if link else 0xEA000000
            return instr_type | ((offset >> 2) & 0xFFFFFF)

    rtc_init_call_instr, rtc_init_call_addr, rtc_code_block_addr, vblank_handler_end_addr = arm7_rom_offsets[rom_id]

    update_rtcom_func_offset, arm7_patch_bytes = assemble_arm7_rtcom_patch(rtc_code_block_addr, include_nub)
    branch_to_rtcom_update_instruction = instr__arm_b(
        vblank_handler_end_addr, rtc_code_block_addr + update_rtcom_func_offset)

    ####################################################################################
    # Arm7 Patch

    action_replay_code = f"""
        5{rtc_init_call_addr:07X} {rtc_init_call_instr:08X} # if the patch wasn't uploaded yet
            0{rtc_init_call_addr:07X} 00000000  # prevent calling the usual RTC routines
            {ar_code__bulk_write(arm7_patch_bytes, rtc_code_block_addr)} # write the Arm7 + Arm11 code
            0{vblank_handler_end_addr:07X} {branch_to_rtcom_update_instruction:08X} # Hook the VBlank IRQ Handler
        D2000000 00000000
    """

    ####################################################################################
    # Arm9 Patch
    include_nub_cheat = ""
    if include_nub:
        # map ZL&ZR to camera rotation buttons (add them as 13th & 14th buttons)
        addr = arm9_mode_specific_btn_map_table_address[rom_id]
        for i in range(3):
            zr_map_address = addr + i * 32 + 24
            zl_map_address = zr_map_address + 2
            include_nub_cheat += f"1{zr_map_address:07X} {0x0100:08X}\n"
            include_nub_cheat += f"1{zl_map_address:07X} {0x0200:08X}\n"

    current_rom_offsets = arm9_rom_function_offsets[rom_id]
    arm9_patch_code, arm9_patch_asm = assemble_arm9_controls_hook_patch(get_asm_symbols_params(*current_rom_offsets))

    controls_hook_addr = arm9_rom_function_offsets[rom_id][0]
    read_cpad_offset = find_function_offset_in_asm_listing(arm9_patch_asm, "LoadValueFromStick")
    controls_hook_branch_instr = instr__arm_b(controls_hook_addr, ARM9_CONTROLS_BASE_PATCH_ADDR + read_cpad_offset)

    action_replay_code += f"""
        5{controls_hook_addr:07X} E7D01108 # if the patch wasn't uploaded yet
            {ar_code__bulk_write(arm9_patch_code, ARM9_CONTROLS_BASE_PATCH_ADDR)}
            
            # insert an instruction to branch into the patch code from the sm64ds' controls routine;
            0{controls_hook_addr:07X} {controls_hook_branch_instr:08X}
            {include_nub_cheat}
        D2000000 00000000
    """

    # remove comments, indentation, and empty lines
    formatted_cheatcode = ""
    for line in action_replay_code.splitlines():
        mb_nonempty_line = line.split('#')[0].strip()
        if len(mb_nonempty_line) > 0:
            formatted_cheatcode += mb_nonempty_line + '\n'

    return formatted_cheatcode


def generate_action_replay_codes_for_all_rom_versions():
    ac_folder_name = "action_replay_codes"
    Path(ac_folder_name).mkdir(exist_ok=True)

    cheat_codes = defaultdict(list)
    for include_nub in [False, True]:
        for rom_id, _ in arm9_rom_function_offsets.items():
            filename = f"{rom_id} ({rom_descriptions[rom_id]})"

            code_text = generate_action_replay_code(rom_id, include_nub)
            nub_postfix = " [with Nub stick, ZL and ZR]" if include_nub else ""
            with open(f"{ac_folder_name}/{filename+nub_postfix}.txt", "w") as f:
                f.write(code_text)

            cheat_codes[rom_id].append({'code': code_text, 'name': "CPAD" + nub_postfix})

    usrcheat_dat_file = generate_usrcheat_dat_file_with_ar_codes(cheat_codes)
    with open(f'{ac_folder_name}/usrcheat.dat', 'wb') as f:
        f.write(usrcheat_dat_file)


def generate_usrcheat_dat_file_with_ar_codes(patches: dict):
    def make_ar_file_header():
        main_header = bytearray(b'\0' * 0x100)
        main_header[0:0xC] = b'R4 CheatCode'
        main_header[0xD] = 1
        db_name = b"SM64DS with CPad AR Codes"
        struct.pack_into(f'{len(db_name)}s', main_header, 0x10, db_name)
        struct.pack_into('<I', main_header, 0x4C, 0x594153d5)
        main_header[0x50] = 1
        return main_header

    def make_ar_game_header(game_name, n_code):
        game_name = game_name.encode()
        game_header = game_name + b'\0' * (4 - len(game_name) % 4)
        game_attribute_header = bytearray(0x24)
        game_attribute_header[0] = n_code
        game_attribute_header[8] = 1
        game_header += game_attribute_header
        return game_header

    def get_ar_code_values_from_text(codes):
        ar_code_values = []
        for line in codes.splitlines():
            columns = line.split()
            if len(columns) != 2:
                continue
            ar_code_values.append(int(columns[0], 16))
            ar_code_values.append(int(columns[1], 16))
        return ar_code_values

    def make_ar_code_record(code_name, code_description, ar_code_values):
        # Code Header
        ar_code_name = code_name.encode()
        ar_code_description = code_description.encode()
        ar_code_header = ar_code_name + b'\0'
        ar_code_header += ar_code_description
        ar_code_header += b'\0' * (4 - len(ar_code_header) % 4)

        # AR Code Record
        ar_code = struct.pack(f"<{len(ar_code_values)}I", *ar_code_values)
        ar_code_size = len(ar_code)
        ar_code_header += struct.pack("<I", ar_code_size // 4)
        ar_code_size_with_header = ar_code_size + len(ar_code_header)
        ar_code_header = struct.pack("<I", ar_code_size_with_header // 4) + ar_code_header

        ar_code_record = ar_code_header + ar_code
        return ar_code_record

    n_games = len(patches)

    # Game Position Table
    game_pos_table = bytearray(0x10 * n_games)

    game_codes = defaultdict(list)
    for i, (rom_id, roms_info) in enumerate(patches.items()):
        gamecode, crc32_str = rom_id.split('-')
        struct.pack_into('<4sI', game_pos_table, 0x10 * i, gamecode.encode(), int(crc32_str, 16))

        for rom_code in roms_info:
            ar_code_record = make_ar_code_record(rom_code['name'], "",
                                                 get_ar_code_values_from_text(rom_code['code']))
            game_codes[rom_id].append(ar_code_record)

    # Make it Whole
    usrcheat_dat_file = bytearray()
    usrcheat_dat_file += make_ar_file_header()
    usrcheat_dat_file += game_pos_table + bytes(0x10)

    for i, (rom_id, rom_codes) in enumerate(game_codes.items()):
        struct.pack_into('<I', usrcheat_dat_file, 0x100 + i * 0x10 + 8, len(usrcheat_dat_file))
        usrcheat_dat_file += make_ar_game_header(rom_id, n_code=len(rom_codes))
        for rom_code in rom_codes:
            usrcheat_dat_file += rom_code

    return usrcheat_dat_file


def main():
    tmp_folder_path = Path(tmp_folder_name)
    tmp_folder_existed = tmp_folder_path.exists()
    if not tmp_folder_existed:
        tmp_folder_path.mkdir()

    if rom_path:
        include_nub = True
        patch_rom(rom_path, include_nub)
    else:
        generate_action_replay_codes_for_all_rom_versions()

    if not tmp_folder_existed:
        import shutil
        shutil.rmtree(tmp_folder_name)


main()
